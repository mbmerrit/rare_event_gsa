function [multiIndex, nPCTerms] = uq_initMultiIndex(nord, ndim)
% function: uq_initMultiIndex
% purpose:  returns the multi-index for the PC basis 
%           
% usage: [multiIndex, nPCTerms] = uq_initMultiIndex(nord, ndim) 
%
% input: 
%    nord: order of expansion
%    ndim: stochastic dimension
%
% output:
%    multiIndex: multi-index matrix 
%    nPCTerms: number of terms in PC expansion.
%
% note: this code returns the multi-index correponding to
%       a truncated PCE based on total degree of polynomials.
%
% Licensing:
%
%     Copyright (2011) Sandia Corporation. Under the terms of Contract
%     DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government
%     retains certain rights in this software.
%
%     This file is part of The UQ Toolkit (UQTk)
%
%     UQTk is free software: you can redistribute it and/or modify
%     it under the terms of the GNU Lesser General Public License as published by
%     the Free Software Foundation, either version 3 of the License, or
%     (at your option) any later version.
%
%     UQTk is distributed in the hope that it will be useful,
%     but WITHOUT ANY WARRANTY; without even the implied warranty of
%     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%     GNU Lesser General Public License for more details.
%
%     You should have received a copy of the GNU Lesser General Public License
%     along with UQTk.  If not, see <http://www.gnu.org/licenses/>.
%
%     Questions? Contact Bert Debusschere <bjdebus@sandia.gov>
%     Sandia National Laboratories, Livermore, CA, USA


maxP = 200;
multiIndex = zeros(maxP, ndim);
%       zero-th order term

nPCTerms = 1;                 % nPCTerms = 1  corresponds to zero order term
np(nPCTerms) = 0;             % order of term nPCTerms
for i = 1 : ndim
   multiIndex(nPCTerms,i) = 0;
end

nn(0+1) = 1;               % number of terms of order 0

if (nord > 0) 
%          first order terms

   for j = 1 : ndim
      nPCTerms = nPCTerms+1;
      np(nPCTerms) = 1;          % order of term nPCTerms

      for i = 1 : j-1      % multi_index(nPCTerms,j)=delta_nPCTerms,j
         multiIndex(nPCTerms,i)=0;
      end

      multiIndex(nPCTerms,j) = 1;

      for i = j+1 : ndim
         multiIndex(nPCTerms,i)=0;
      end 
   end

   for i = 1 : ndim
      ic(i) = 1;           % number of terms of this order generated by
                           % increasing order of dimension i by one
                           % in the terms of previous order
   end

   nn(1+1) = ndim;         % number of terms of order 1

   if(nord > 1)
      % higher order terms

      for k = 2 : nord

         IP = nPCTerms;         %number of terms with order less than k

         for j=1 : ndim
            isum = 0;
            for l = ndim : -1 : j
               isum = isum + ic(l);
            end
            ict(j) = isum;
         end

         for j = 1 : ndim
            ic(j) = ict(j);   %number of terms of this order generated by
                              %increasing order of dimension i by one
                              %in the terms of previous order
         end

         for jj = 1 : ndim
            for j = IP-ic(jj)+1 : IP       %get next ic(jj) terms by increasing order
                                           %of dimension jj in the last ic(jj) terms
                                           %of the previous order
               nPCTerms = nPCTerms+1;
               np(nPCTerms) = k;                 % order of this term
               for i = 1 : ndim
                  multiIndex(nPCTerms,i) = multiIndex(j,i);
               end
               multiIndex(nPCTerms,jj) = multiIndex(nPCTerms,jj)+1;    %increase order of dimension jj
                                              %by one to get the next term
            end
         end
         nn(k+1) = nPCTerms - IP;                  %number of terms with order k
      end
   end
end     

% cut the unused part of the matrix
multiIndex = multiIndex(1:nPCTerms, :);
